# AI-Cognitive-Soar-
# Горячко Виктор Олегович группа 155 проект: AI-Cognitive: системы Soar и ACT-R.
В проекте рассматривается когнитивная архитектура Soar. Но для начала рассмотрим, что такое когнитивные архитектуры и почему данная тематика сегодня очень актуальна. Итак, когнитивная архитектура - это основа(фреймворк) для создания интеллектуальных агентов. Интеллектуальные агенты - это когнитивные системы, встроенные в виртуальную или физическую среду, которые могут воспринимать информацию и выполнять действия необходимые для агента. Когнитивные архитектуры реализуют не только различные аспекты когнитивного поведения, но познания в целом. На данный момент архитектуры пытаются воспроизвести поведения высших когнитивных процессов человеческого мозга, к сожалению данные процессы недостаточно хорошо изучены, что усложняет решение проблемы. Из возможностей когнитивных архитектур можно выделить: распознавание и категоризация, принятие решений и выбор, восприятие и оценивание ситуации, прогнозирование и мониторинг, решение задач и планирование, обеспечение рассуждений и убеждений, исполнение и действие, взаимодействие и общение, запоминание отражение и обучение. Также когнитивные системы имеют и отличное практическое применение. Например, все современные робототехнические системы (дроны, пылесосы, человекоподобные роботы) управляются специальным программным обеспечением. Самые интересные, сложные функции (планирование поведения и рассуждения) реализуются специальным их типом - когнитивными архитектурами. Сейчас существует много различных когнитивных архитектур, например, такие: Soar, ACT-R, PreAct, ICARUS, CLARION, FORR.
# Теперь рассмотрим подробнее выбранную нами для проекта когнитивную архитектуру Soar.
Создавалась John Laird, Allen Newell, и Paul Rosenbloom в Carnegie Mellon University с 1983 года. Широко используется исследователями для моделирования различных аспектов поведения человека. Основная цель проекта добиться полного выполнения всех возможностей интеллектуальных агентов. Soar использует точные правила для определения поведения (такие как "if... then..."). Если не описано точно поведения для конкретной процедуры, то в Soar применяется различные стратегии, например, методы для решения тупика. Когда решение найдено, Soar применяет методику обучения, называемую chunking, позволяющую создать новое правило. Здесь стоит отметить отличие Soar от ACT-R, в Soar новые правила записываются в долгосрочную память, в то время как в ACT-R правила запишется в кратковременную память, то есть в этих архитектурах различается работа с памятью. Более того системы написаны на разных языках программирования Soar – Java, ACT-R LISP. 
# Одни из значимых достижений Soar:
* Исследователи использовали Soar для разработки разнообразных изощренных агентов, которые продемонстрировали впечатляющую функциональность. Наиболее заметным был агент TAC-Air-Soar [Tambe et al., 1995], который моделировал пилотов истребителей в военных учениях, в которых применялись сценарии воздушных боев. 
* Совсем недавно архитектура Soar стала поддерживаться рядом интеллектуальных агентов, которые управляют синтетическими персонажами в интерактивных компьютерных играх [Magerko et al., 2004].
* Другой успех связан с использованием Soar в моделировании деталей обработки человеческого языка [Lewis, 1993], категоризации [Miller & Laird, 1996].
# Отчет по КТ2.
 В ходе работы была рассмотрена архитектура системы. Подробно разобраны принципы и возможности работы с системой Soar. Выполнены все упражнения из туториала. Ниже приведу отчет об архитектуре Soar и инструкцию по запуску.
 # Архитектура Soar.
В архитектуре системы можно выделить следующие части: временная, постоянная память, и основные процессы архитектуры. Постоянная память в системе служит для хранения правил для агента. Временная память нужна для размещения временных данных (например, результаты вычислений), для хранения некоторых структур (переменные, структуры), также хранится вся информация с сенсоров, текущие состояние и цель. Главная особенность временной памяти, состоит в том, что она представлена в виде графа, такая структура обоснована тем что в системе правила могут подходить для различных состояний, а также выполняться параллельно. Также все переменные и структуры в памяти глобальны. Основные процессы архитектуры — это создание состояний, принятие решений, обучение и планирование. Опишем кратко основной цикл работы системы первая фаза получение данных из внешнего мира (input phase), на данном этапе мы получаем данные с сенсоров, местоположение агента и информацию о нем. Далее фаза предложения операторов (propose phase ), на данном этапе выбираются подходящие операторы для данного случая. Следующий этап — это выбор нужного оператора (decision phase). Потом идет применение выбранного на предыдущем шаге оператора (apply phase). И в итоге (output phase) вывод информации в внешний мир(world), с которым взаимодействует агент.
# Инструкция по компиляции, установке и запуску.
Для запуска необходимо скачать версию Soar в данном случае подойдет, например, туториал отсюда http://soar.eecs.umich.edu/Downloads. Либо скачать все файлы из репозитория. Рассмотрим запуск Eaters. Сначала запустим Eaters.command в появившемся окне сразу увидим карту (мир), в котором будет находится наш агент. Если при запуске Eaters.command не запускается окно с картой, то необходимо в появившемся окне выбрать eaters.cnf. Создадим нового агента: под Agents кнопка New, в появившемся окне можно задать цвет и имя созданного агента, создадим Soar агента нажав кнопку Soar. Выбираем файл с правилами advanced-move_ready.soar. Далее нажав Create Agent будет создан агент, откроется также окно debugger. Теперь можно запускать агента, нажав в первом окне run, если мы хотим отследить работу агента, то используем debugger для запуска и отслеживания работы.
# Результаты проекта.
В результате проекта написан агент для Eaters. В котором реализован "жадный" подход к выбору направления движения, то есть считаем, что движение к бонусной еде намного лучше, чем к простой. Так как бонусная еда дает больше баллов, а также рядом с ней может находится еще бонусная еда. Поэтому eater исходя из информации с сенсора выбирает направление движения к ближайшей бонусной еде и движется в этом направлении. Исключаются из рассмотрения направления движения, где сразу возле eater находится стена. В ходе проекта мной был рассмотрен другой подход, предлагаемый авторами Soar, а именно планирование. Но получилось, что реализованный мной "жадный" подход работает также, так как для полноценного планирования данных с сенсора просто недостаточно. Реализованная модификация позволяет собрать бонусную еду первым, что дает преимущество перед другими eaters.
